# Понятие сокета

Готово — тема: **Понятие сокета**.

## Понятие сокета

> Кратко: сокет — конечная точка сетевого общения. Это пара (адрес,порт) + API для отправки/приёма данных.

### Что такое сокет

* **Сокет (socket)** — программный интерфейс для работы с сетевыми соединениями.
* В сетях IPv4/IPv6 сокет идентифицируется кортежем: `(<IP>, <порт>)`.
* Для установленных TCP-соединений уникальная 4-ка: `(localIP, localPort, remoteIP, remotePort)`.

### Типы сокетов

* **SOCK\_STREAM** — потоковый (TCP). Гарантирует порядок и надёжность.
* **SOCK\_DGRAM** — дейтаграммный (UDP). Без установления соединения, ненадёжный.
* **SOCK\_RAW** — доступ к сырым IP-пакетам (обычно требует root).
* **UNIX domain sockets** — межпроцессное общение в той же системе (path вместо IP).

### Портовые диапазоны

* **Well-known**: $$0..1023$$ (системные сервисы).
* **Registered**: $$1024..49151$$.
* **Ephemeral (динамические)**: $$49152..65535$$ (клиентские временные порты, ОС выбирает).

### Жизненный цикл (сервер vs клиент) — псевдокод

**Сервер (TCP)**:

```python
s = socket(AF_INET, SOCK_STREAM)
bind(s, (0.0.0.0, 8080))
listen(s, backlog)
while true:
    conn, addr = accept(s)
    handle(conn)
```

**Клиент (TCP)**:

```python
c = socket(AF_INET, SOCK_STREAM)
connect(c, (server_ip, 8080))
send(c, data)
recv(c)
close(c)
```

### Blocking / non-blocking и мультиплексирование

* По умолчанию сокеты блокирующие. Можно сделать неблокирующими (`fcntl`/`ioctl`) или использовать `setblocking(0)`.
* Для нескольких соединений используют `select`, `poll`, `epoll` (Linux) или `kqueue` (BSD). `epoll` эффективен для большого числа сокетов.

### Важные опции сокета (часто на экзамене)

* `SO_REUSEADDR` — разрешает повторный bind на адрес в TIME\_WAIT; полезно для разработки/перезапуска сервера.
* `SO_KEEPALIVE` — периодические keepalive-пакеты для обнаружения мёртвого пира.
* `SO_LINGER` — контролирует поведение close при наличии несосланных данных.
* `TCP_NODELAY` (через `setsockopt`) — отключает Nagle (уменьшает задержку мелких пакетов).

### TIME\_WAIT и почему `SO_REUSEADDR` полезен

* При закрытии TCP соединения сторона в состоянии `TIME_WAIT` держит 2×MSL (макс. сегмент жизни). Это предотвращает конфликт старых пакетов.
* `SO_REUSEADDR` позволяет быстро вернуть порт для bind (с учётом риска). Понимая TIME\_WAIT — корректно проектируют перезапуск сервисов.

### Диагностика сокетов

* Посмотреть слушающие/установленные сокеты: `ss -tulpen` / `netstat -tulpen`.
* Посмотреть, какой процесс держит порт: `ss -lnp` / `fuser -n tcp 8080`.
* Захват пакетов при отладке: `tcpdump -n -i eth0 tcp port 80`.

### Ключевые тезисы для экзамена

1. Сокет = endpoint = (IP, port). TCP-соединение — уникальная 4-ка.
2. `SOCK_STREAM` = TCP, `SOCK_DGRAM` = UDP.
3. Сервер: `socket→bind→listen→accept`; клиент: `socket→connect`.
4. `SO_REUSEADDR` помогает при TIME\_WAIT; `epoll` — масштабируемая демультиплексирующая схема.
5. UNIX-sockets — альтернатива для локального IPC, быстрее и без IP-стека.

### Вопросы для самопроверки

1. Чем отличается слушающий сокет от установленного соединения?
2. Почему при перезапуске сервера часто используют `SO_REUSEADDR`?
3. Когда применяют `SOCK_RAW` и какие риски он несёт?
