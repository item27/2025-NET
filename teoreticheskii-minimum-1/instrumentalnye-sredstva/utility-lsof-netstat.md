---
description: получение информации о прослушиваемых портах, об активных соединениях
---

# Утилиты lsof, netstat

> Кратко: `lsof` показывает открытые файлы и сокеты процессов. `netstat` показывает сетевые сокеты, таблицы маршрутизации и статистику. На Linux `ss` заменяет `netstat`, но знать `netstat` полезно.

## `lsof` — кратко

* `lsof` = list open files. Сокеты в UNIX рассматриваются как файлы.
* Полезно найти процесс по порту или показать, какие порты держит процесс.

### Частые команды

```bash
# все сетевые файлы
lsof -i

# слушающие TCP-сокеты (без DNS/портов в числовом виде)
lsof -iTCP -sTCP:LISTEN -Pn

# кто слушает порт 80
lsof -i :80

# показать соединения процесса PID
lsof -p 1234

# все unix-domain сокеты
lsof -U

# фильтр по адресу/протоколу
lsof -i @192.168.1.10
```

### Что читаем в выводе `lsof`

* `COMMAND` — имя процесса.
* `PID` — идентификатор процесса.
* `USER` — владелец процесса.
* `FD` — file descriptor (например `3u`), `TCP`/`UDP` в столбце `TYPE`/`NODE`.
* `NAME` — адрес:порт или путь unix-сокета.

### Практические примеры

* Убить процесс, который занимает порт:

```bash
PID=$(lsof -t -i :8080) && kill $PID
```

* Найти процессы, открывшие много сокетов (поисковая эвристика при утечках):

```bash
lsof -i | awk '{print $2}' | sort | uniq -c | sort -nr | head
```

## `netstat` — кратко

* `netstat` показывает таблицы маршрутизации, состояния сокетов и статистику протоколов.
* На современных Linux лучше `ss` (`iproute2`), но `netstat` доступен во многих системах.

### Частые команды

```bash
# слушающие сокеты (TCP/UDP), с PID/Program (Linux)
netstat -tulpen

# все соединения (анонимно)
netstat -an

# статистика по протоколам
netstat -s

# таблица маршрутизации
netstat -r

# показать только TCP
netstat -tn

# показать только UDP
netstat -un
```

### Что читаем в выводе `netstat -tulpen`

* `Proto` — протокол (tcp/udp).
* `Recv-Q` / `Send-Q` — очередь приема/передачи (bytes). Большие значения — проблемы.
* `Local Address` / `Foreign Address` — локальный и удалённый адрес.
* `State` — ESTABLISHED, LISTEN, TIME\_WAIT и т.д.
* `PID/Program name` — процесс, держащий сокет.

### Примеры и интерпретация

* `Recv-Q` > 0 на слушающем сокете → приложение не читает данные.
* Много `TIME_WAIT` — нормальное поведение при большом количестве коротких TCP-соединений.
* `SYN_RECV`/`SYN_SENT` — проблемы при установлении соединений (возможен SYN-flood или неполадки на стороне клиента/сервера).

## Сопоставление `lsof` + `netstat` + `ss`

* `ss -tulpen` — современная замена `netstat -tulpen`, быстрее и информативнее.
* Используйте `lsof` чтобы быстро получить PID и путь бинарника.
* Используйте `ss`/`netstat` чтобы оценить состояние соединений и очереди.

### Примеры рабочих сценариев

1. Клиент жалуется, что сервис недоступен:
   * `ss -tlnp | grep :8080` — проверить слушает ли сервис.
   * `lsof -i :8080` — узнать PID и user.
   * `ps -fp <PID>` — посмотреть командную строку процесса.
   * `ip route get <client-ip>` / `tcpdump -n -i <if> port 8080` — дальше L3/L2 диагностика.
2. Сервер делает много `TIME_WAIT`:
   * Проверить с `ss -s` / `netstat -s`.
   * Оценить необходимость keepalive, connection reuse, или перенастройки сокетов в приложении.

## Дополнительно: полезные трюки

* Только PID из `lsof`: `lsof -t -i :22`
* grep-friendly: `lsof -iTCP -sTCP:LISTEN -Pn | awk '{print $1,$2,$9}'`
* Просмотреть сокеты конкретного пользователя: `lsof -u alice -i`

## Короткие экзаменационные тезисы

1. `lsof` показывает какие процессы открыли какие сокеты и файлы.
2. `netstat` показывает сетевые состояния, таблицу маршрутизации и статистику протоколов.
3. `ss` — быстрый современный аналог `netstat`.
4. `Recv-Q/Send-Q` в `netstat`/`ss` сигнализируют о проблемах с чтением/записью.
5. Для устранения проблем сопоставляйте вывод `ss/netstat` (состояние) и `lsof` (PID, binary).

## Вопросы для самопроверки

1. Как найти процесс, слушающий порт 3306?
2. Что означает ненулевой `Recv-Q` на LISTEN-сокете?
3. Чем `ss -tulpn` лучше чем `netstat -tulpn`?
